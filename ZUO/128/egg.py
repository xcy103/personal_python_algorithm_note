# 核心思维逆转常规的思考方式是：“给定 $k$ 个鸡蛋和 $n$ 层楼，最少需要扔几次？”
# 这种思路会导致 $O(k \cdot n^2)$ 甚至更复杂的复杂度。
# 最优解思路（逆向思维）：“给定 $k$ 个鸡蛋，如果允许你扔 $t$ 次，你最高能测出多少层楼？”
# 假设这个函数为 $f(k, t)$。

# 当你扔下一枚鸡蛋：
# 鸡蛋碎了：你还剩 $k-1$ 个鸡蛋和 $t-1$ 次机会，可以向下测 $f(k-1, t-1)$层。
# 鸡蛋没碎：你还剩 $k$ 个鸡蛋和 $t-1$ 次机会，可以向上测 $f(k, t-1)$ 层。
# 加上当前层：再计入你扔鸡蛋的那一层。
# 转移方程：$$f(k, t) = f(k-1, t-1) + f(k, t-1) + 1$$
# 我们将 $t$ 逐步增加，直到 $f(k, t) \ge n$ 为止，
# 此时的 $t$ 就是答案。

def super_egg_drop(k: int, n: int) -> int:
    # 如果只有一个鸡蛋，只能一层一层从下往上试，需要 n 次
    if k == 1:
        return n
    
    # dp[i] 表示当前扔 t 次，拥有 i 个鸡蛋时能测出的最大楼层
    dp = [0] * (k + 1)
    
    # t 代表尝试次数，从 1 开始增加
    for t in range(1, n + 1):
        # 必须从后往前更新，避免使用本轮刚更新过的值（类似 01 背包空间优化）
        pre = 0
        for i in range(1, k + 1):
            tmp = dp[i]
            # 当前能测出的高度 = 碎了能测的高度 + 没碎能测的高度 + 1
            dp[i] = dp[i] + pre + 1
            pre = tmp
            
            # 如果当前鸡蛋数和尝试次数已经能覆盖 n 层楼，直接返回结果
            if dp[i] >= n:
                return t
    return -1

# 测试
print(super_egg_drop(2, 100)) # 输出 14