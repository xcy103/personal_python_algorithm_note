# 这道题是之前左讲过的根据数量猜解法，最朴素的就是
# 区间DP，把每个点当作最后部署，然后根据这个去求收益
# 但是这道题数据量很大，我们需要用线性DP，需要巧妙设计状态

# 这个 DP 实际上在做一个决策博弈：对于每一对相邻的机器 $(i, i+1)$，
# 只有两种部署顺序：
# 先部署 $i$，后部署 $i+1$：
# $i$ 部署时看不到 $i+1$，但 $i+1$ 部署时能看到 $i$。
# 先部署 $i+1$，后部署 $i$：
# $i+1$ 部署时看不到 $i$，但 $i$ 部署时能看到 $i+1$。

# 通过 dp[i][0] 和 dp[i][1]，我们巧妙地把“未来的决策”对“当前收益”的影响给涵盖进去了。
# no[i] + dp[i+1][1]：我先部署 $i$，所以我拿 no 收益，
# 而因为我已经在位了，我右边的兄弟 $i+1$ 部署时一定会看到我，所以他必须从 dp[i+1][1] 开始选。
# one[i] + dp[i+1][0]：我打算等 $i+1$ 部署完后再部署 $i$，
# 所以我拿 one 收益，而我右边的兄弟部署时我还不在，所以他从 dp[i+1][0] 开始选。
def solve(n, no, one, both):
    """
    n: 机器数量
    no, one, both: 长度为 n+1 的数组 (下标从 1 开始)
    """
    if n == 0:
        return 0
    
    # dp[i][0] : i 号机器的前一台机器 (i-1) 还没部署时，部署 i...n 机器的最大收益
    # dp[i][1] : i 号机器的前一台机器 (i-1) 已经部署时，部署 i...n 机器的最大收益
    # 初始化 dp 数组，大小为 (n + 2) x 2 以防越界
    dp = [[0, 0] for _ in range(n + 2)]
    
    # 填表方向：从后往前
    # 边界情况：最后一台机器
    dp[n][0] = no[n]
    dp[n][1] = one[n]
    
    for i in range(n - 1, 0, -1):
        # 情况 1：i-1 没部署
        #   - 如果先部署 i：收益为 no[i] + (后续 i+1 看到 i 已部署的收益)
        #   - 如果后部署 i：收益为 one[i] + (后续 i+1 看到 i 还没部署的收益)
        dp[i][0] = max(no[i] + dp[i + 1][1], one[i] + dp[i + 1][0])
        
        # 情况 2：i-1 已部署
        #   - 如果先部署 i：收益为 one[i] + (后续 i+1 看到 i 已部署的收益)
        #   - 如果后部署 i：收益为 both[i] + (后续 i+1 看到 i 还没部署的收益)
        dp[i][1] = max(one[i] + dp[i + 1][1], both[i] + dp[i + 1][0])
        
    return dp[1][0]