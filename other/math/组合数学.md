# 🚀 算法竞赛解题笔记 (Python)

---

## 1. 强盗与锁 (Bandits and Locks)

### 📝 题目描述
一组 $n$ 个强盗偷了宝藏。他们希望只有在至少 $m$ 个强盗同意时才能打开门。为此，他们在门上安装了若干把锁，只有所有锁都被打开时，门才能打开。每把锁有若干钥匙，分给强盗。求最少需要安装多少把锁，使得：
1. 任意 $\ge m$ 个强盗凑在一起，能打开所有锁。
2. 任意 $< m$ 个强盗凑在一起，至少有一把锁打不开。

### 💡 核心逻辑
- **核心思想**：利用“最大失败群体”来定义锁。
- **失败情况**：任意 $m-1$ 个人组成的小组必须“打不开门”。为了让锁的数量最少，我们让每一个这样的 $m-1$ 人小组都对应一把**唯独他们没有钥匙**的锁。
- **钥匙分配**：对于某把锁，除了这特定的 $m-1$ 个人，剩下的所有强盗都有这把锁的钥匙。
- **结论**：锁的数量 = 从 $n$ 个人中选出 $m-1$ 个人的所有组合数。
- **数学公式**：$Ans = C(n, m-1)$



### 🐍 Python 源代码
```python
import math
import sys

def solve():
    # 使用 sys.stdin.read 一次性读取并按空格切分
    input_data = sys.stdin.read().split()
    if not input_data:
        return
    
    t_cases = int(input_data[0])
    curr = 1
    
    for _ in range(t_cases):
        n = int(input_data[curr])
        m = int(input_data[curr + 1])
        curr += 2
        
        # 根据推导，答案即为从 n 中取 m-1 的组合数
        # Python 3.8+ 自带 math.comb 函数
        print(math.comb(n, m - 1))

if __name__ == "__main__":
    solve()